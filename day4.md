# Day 4: Pythonè¾…åŠ©å·¥å…·é“¾


## Part I: NumPyçŸ¢é‡åŒ–è¿ç®—ï¼šå¤„ç†æ¿€å…‰é›·è¾¾ç‚¹äº‘



**ã€ŠNumPyç‚¹äº‘æ–™ç†æœ¯ï¼šåƒåšæŠ«è¨ä¸€æ ·å¤„ç†æ¿€å…‰é›·è¾¾æ•°æ®ã€‹**

---

### ğŸ• **åœºæ™¯ä¸€ï¼šåŸå§‹äººå¼ç‚¹äº‘å¤„ç†**
å‡è®¾ä½ åˆšæ‹¿åˆ°æ¿€å…‰é›·è¾¾æ•°æ®ï¼Œåƒä¸ªåŸå§‹äººä¸€æ ·æŒ¥èˆforå¾ªç¯ï¼š
```python
points = [...]  # å‡è®¾æ˜¯10ä¸‡ä¸ªç‚¹çš„(x,y,z)åˆ—è¡¨
filtered_points = []
for x, y, z in points:
    if x**2 + y**2 + z**2 < 50:  # ç­›é€‰5ç±³å†…çš„ç‚¹
        filtered_points.append([x*0.95, y*0.95, z])  # åšç‚¹åæ ‡ä¿®æ­£
```
**ç»“æœ**ï¼š
ä½ çš„CPUåƒè¸©å•è½¦å‘ç”µçš„ä»“é¼ ï¼Œ10ä¸‡æ¬¡å¾ªç¯åç¨‹åºå‘˜å¤´é¡¶æ¯”ç‚¹äº‘è¿˜ç¨€ç–

---

### ğŸš€ **çŸ¢é‡åŒ–é™ä¸´ï¼šæŠ«è¨åº—æµæ°´çº¿é­”æ³•**
ç”¨NumPyå¼€å¯å·¥ä¸šåŒ–ç”Ÿäº§æ¨¡å¼ï¼š
```python
import numpy as np

# æŠŠç‚¹äº‘å˜æˆæ•°å­—æŠ«è¨é¢å›¢
points = np.array(points)  # ç°åœ¨æ˜¯ä¸ª3åˆ—çš„å¤§çŸ©é˜µ

# æ­¥éª¤1ï¼šæ‰¹é‡è®¡ç®—è·ç¦»ï¼ˆè‡ªåŠ¨é“ºæ»¡æ‰€æœ‰ç‚¹ï¼‰
distances = np.linalg.norm(points, axis=1)

# æ­¥éª¤2ï¼šç”¨å¸ƒå°”é¢å…·ç­›é€‰è¿‘ç‚¹ï¼ˆåƒæŠ«è¨æ¨¡å…·å‹å‡ºå½¢çŠ¶ï¼‰
mask = distances < 5.0
filtered = points[mask]

# æ­¥éª¤3ï¼šçŸ©é˜µçº§åæ ‡ä¿®æ­£ï¼ˆä¸ç”¨å¾ªç¯ï¼ï¼‰
filtered[:, :2] *= 0.95  # x,yåæ ‡æ‰“95æŠ˜
```
**æ•ˆæœ**ï¼š
æ¯”forå¾ªç¯å¿«30å€ï¼Œå°±åƒç”¨ç«ç®­ç‚‰çƒ¤æŠ«è¨ vs é’»æœ¨å–ç«

---

### ğŸ¯ **å®æˆ˜æŠ€å·§ï¼šç‚¹äº‘å¤„ç†çš„å…­è„‰ç¥å‰‘**

**1. é™ç»´æ‰“å‡»ï¼ˆç»Ÿè®¡ç‰¹å¾ï¼‰**
```python
# è®¡ç®—é«˜åº¦ä½äº0.5mçš„ç‚¹çš„å¯†åº¦
ground_points = points[points[:, 2] < 0.5]
density = ground_points.shape[0] / area  # ç¬é—´å¾—å‡º
```

**2. ç©ºé—´æ–—åœ°ä¸»ï¼ˆåŒºåŸŸåˆ†å‰²ï¼‰**
```python
# æŠŠç©ºé—´åˆ’åˆ†æˆ10x10x3çš„ç½‘æ ¼
x_bins = np.linspace(-5, 5, 11)
y_bins = np.linspace(-5, 5, 11)
z_bins = [0, 1, 2, 3]

# ç”¨digitizeç»™æ¯ä¸ªç‚¹å‘"èº«ä»½è¯"
x_indices = np.digitize(points[:,0], x_bins)
y_indices = np.digitize(points[:,1], y_bins)
z_indices = np.digitize(points[:,2], z_bins)
```

**3. çŸ¢é‡å†…åŠŸï¼ˆæ³•å‘é‡è®¡ç®—ï¼‰**
```python
# ç”¨é‚»åŸŸç‚¹åæ–¹å·®çŸ©é˜µçš„ç‰¹å¾å‘é‡
neighbors = [...]  # æŸä¸ªç‚¹çš„å‘¨å›´ç‚¹é›†
cov_matrix = np.cov(neighbors.T)
eigen_values, eigen_vectors = np.linalg.eigh(cov_matrix)
normal_vector = eigen_vectors[:, 0]  # æœ€å°ç‰¹å¾å€¼å¯¹åº”æ–¹å‘
```

---

### ğŸ’£ **å¸¸è§ç¿»è½¦ç°åœº**

**ç¿»è½¦1ï¼šå†…å­˜çˆ†ç‚¸**
```python
# é”™è¯¯ç¤ºèŒƒï¼šç–¯ç‹‚ç”Ÿæˆä¸­é—´å˜é‡
temp1 = points * 2.54
temp2 = temp1[temp1[:,2] > 1]
temp3 = np.dot(temp2, rotation_matrix)
# å†…å­˜ï¼šæˆ‘é€‰æ‹©æ­»äº¡
```
**æ­£ç¡®å§¿åŠ¿**ï¼š
```python
# ä½¿ç”¨åŸåœ°æ“ä½œå’Œè§†å›¾
points *= 2.54  # åŸåœ°ä¿®æ”¹
filtered = points[points[:,2] > 1]
np.dot(filtered, rotation_matrix, out=filtered)
```

**ç¿»è½¦2ï¼šå¹¿æ’­æœºåˆ¶ç†è§£åå·®**
```python
# æƒ³ç»™æ¯ä¸ªç‚¹åŠ åç§»é‡å´...
offset = [0.1, 0.2, 0.3]
points += offset  # æ­£ç¡®ï¼è‡ªåŠ¨å¹¿æ’­
# ä½†å¦‚æœoffsetæ˜¯(3,1)å°±ä¼šç¿»è½¦ï¼
```

**ç¿»è½¦3ï¼šè¯¯ç”¨æ‹·è´è§†å›¾**
```python
view = points[1:100]
view[:, 0] = 999  # ä¼šä¿®æ”¹åŸå§‹æ•°æ®ï¼
# éœ€è¦æ‹·è´æ—¶ï¼šview = points[1:100].copy()
```

---

### ğŸš— **è‡ªåŠ¨é©¾é©¶ç‰¹è°ƒå¥—é¤**

**å¥—é¤1ï¼šå®æ—¶åœ°é¢åˆ†å‰²**
```python
# åˆ©ç”¨é«˜åº¦å’Œæ³•å‘é‡åŒé‡éªŒè¯
ground_mask = (points[:,2] < 0.3) & (normal_vectors[:,2] > 0.9)
```

**å¥—é¤2ï¼šåŠ¨æ€ç‰©ä½“æ£€æµ‹**
```python
# ä¸¤å¸§ç‚¹äº‘å·®å¼‚åˆ†æ
diff = np.linalg.norm(current_points - last_points, axis=1)
moving_mask = diff > 0.5  # åŠç±³ä»¥ä¸Šçš„ä½ç§»
```

**å¥—é¤3ï¼šé¸Ÿç°å›¾ç”Ÿæˆ**
```python
# 2Dç›´æ–¹å›¾æŠ•å½±
heatmap, x_edges, y_edges = np.histogram2d(
    points[:,0], points[:,1], bins=(200, 200))
```

---

### â± **æ€§èƒ½ç„å­¦å¯¹æ¯”**

| æ“ä½œ                | forå¾ªç¯è€—æ—¶ | çŸ¢é‡åŒ–è€—æ—¶ | æ¯”å–»               |
|---------------------|------------|-----------|--------------------|
| 10ä¸‡ç‚¹åæ ‡è½¬æ¢      | 78ms       | 2ms       | é©¬è½¦ vs é«˜é“       |
| 5ä¸‡ç‚¹æ³•å‘é‡è®¡ç®—     | 1.2s       | 0.04s     | æ‰‹æ‰“ç®—ç›˜ vs è®¡ç®—å™¨ |
| å®æ—¶åœ°é¢åˆ†å‰²(æ¯å¸§)  | 210ms      | 6ms       | èœ—ç‰› vs çŒè±¹       |

---

### ğŸ¤– **æœºå™¨äººå·¥ç¨‹å¸ˆçš„è‡ªæˆ‘ä¿®å…»**
1. çœ‹åˆ°forå¾ªç¯å°±æ‰‹æŠ–â€”â€”æ¡ä»¶åå°„å¼è½¬æ¢ä¸ºçŸ©é˜µæ“ä½œ
2. é‡åˆ°å¤æ‚è¿ç®—å…ˆæƒ³"èƒ½ä¸èƒ½ç”¨einsumè¡¨è¾¾"
3. å†…å­˜ä¸å¤Ÿæ—¶ç†Ÿç»ƒä½¿ç”¨np.memmapå¤„ç†200GBç‚¹äº‘
4. çœ‹åˆ°ç‚¹äº‘å¯†åº¦ä¸å‡å°±æ‰‹ç—’æƒ³å†™np.histogramdd
5. åšä¿¡äººç”Ÿä¸‰å¤§çœŸç†ï¼šæ—©ç¡ã€è¿åŠ¨ã€è½´å‚æ•°è°ƒæˆ1

---

**è¯¾åä½œä¸š**ï¼š
ç”¨çŸ¢é‡åŒ–æ“ä½œå®ç°ï¼š
1. æ‰¾å‡ºæ‰€æœ‰æ„æˆ"å·¥"å­—å‹çš„ç‚¹äº‘ç°‡
2. è®¡ç®—æ¯ä¸ªç‚¹åˆ°æœ€è¿‘10ä¸ªé‚»å±…çš„å¹³å‡è·ç¦»
3. ç”Ÿæˆå½©è™¹è‰²ç‚¹äº‘ï¼ˆæ ¹æ®é«˜åº¦æ˜ å°„åˆ°è‰²è°±ï¼‰

ï¼ˆé™„åŠ é¢˜ï¼šå½“è€æ¿è¯´"è¿™ä¸ªå®æ—¶ç‚¹äº‘å¤„ç†ç”¨çº¯Pythonå°±è¡Œ"æ—¶ï¼Œè¯·ä¼˜é›…åœ°æ‰“å¼€NumPyæ–‡æ¡£ç¬¬37é¡µï¼‰

## Part IIï¼šOpenCV-Pythonï¼šå›¾åƒé¢„å¤„ç†æµæ°´çº¿


**ã€ŠOpenCVå¨æˆ¿å¤§ä½œæˆ˜ï¼šç»™å›¾åƒåšSPAçš„æ­£ç¡®å§¿åŠ¿ã€‹**

---

### ğŸ­ **åœºæ™¯ä¸€ï¼šåŸå§‹å›¾åƒã®ç´ é¢œæƒŠé­‚**
å‡è®¾ä½ æ”¶åˆ°ä¸€å¼ æ¥è‡ªæ‘„åƒå¤´çš„"ç´ é¢œç…§"ï¼š
- å™ªç‚¹æ¯”èš‚èšè¿˜å¤š
- äº®åº¦å ªæ¯”åˆå¤œå‡¶é“ƒ
- ç‰©ä½“è¾¹ç¼˜åƒå–é†‰çš„èš¯èš“

```python
import cv2
raw_img = cv2.imread("æš—é»‘æ–™ç†.jpg")  # è¯»å…¥å›¾åƒ
cv2.imshow("å‰æ–¹é«˜èƒ½", raw_img)       # åšå¥½å¿ƒç†å‡†å¤‡
```

---

### ğŸ§™ **é¢„å¤„ç†å…­é‡å¥ï¼šç¾é¢œæ»¤é•œæµæ°´çº¿**

**Step 1ï¼šè‰²å½©ç©ºé—´è½¬æ¢ï¼ˆæ¢è£…èˆä¼šï¼‰**
```python
# ä»BGRåˆ°HSVï¼Œå°±åƒRGBæ¢ä¸Šäº†æ™šç¤¼æœ
hsv_img = cv2.cvtColor(raw_img, cv2.COLOR_BGR2HSV)
# åˆ°ç°åº¦å›¾ï¼šè„±æ‰é¢œè‰²å¤–è¡£
gray_img = cv2.cvtColor(raw_img, cv2.COLOR_BGR2GRAY)
```

**Step 2ï¼šç›´æ–¹å›¾å‡è¡¡åŒ–ï¼ˆæ‰“å…‰å¸ˆä¸Šçº¿ï¼‰**
```python
# CLAHEé­”æ³•ï¼šå±€éƒ¨å¯¹æ¯”åº¦å¢å¼º
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
enhanced_img = clahe.apply(gray_img)
```

**Step 3ï¼šé«˜æ–¯æ¨¡ç³Šï¼ˆç£¨çš®ç¥å™¨ï¼‰**
```python
# é«˜æ–¯æ ¸å°ºå¯¸è¦æ˜¯å¥‡æ•°ï¼å¦åˆ™ä¼šè§¦å‘è¯…å’’
blurred = cv2.GaussianBlur(enhanced_img, (5,5), 0)
```

**Step 4ï¼šè¾¹ç¼˜æ£€æµ‹ï¼ˆæçœ‰ç”»çœ¼ï¼‰**
```python
# Cannyè¾¹ç¼˜æ£€æµ‹ï¼šåŒé˜ˆå€¼ç„å­¦
edges = cv2.Canny(blurred, threshold1=30, threshold2=150)
```

**Step 5ï¼šå½¢æ€å­¦æ“ä½œï¼ˆç˜¦è„¸å¡‘å½¢ï¼‰**
```python
# å…ˆè†¨èƒ€å†è…èš€ï¼ˆé—­è¿ç®—ï¼‰
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3))
morphed = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)
```

**Step 6ï¼šè½®å»“æŸ¥æ‰¾ï¼ˆéª¨éª¼å®šä½ï¼‰**
```python
contours, _ = cv2.findContours(morphed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
# ç°åœ¨å¯ä»¥ç»™ç‰©ä½“ç”»é©¬ç”²çº¿äº†
cv2.drawContours(raw_img, contours, -1, (0,255,0), 2)
```

---

### ğŸš¨ **ç¿»è½¦ç°åœºï¼šé¢„å¤„ç†ã®100ç§æ­»æ³•**

**ç¿»è½¦1ï¼šé¢œè‰²ç©ºé—´é”™ä¹±ç—‡**
```python
# é”™è¯¯ç¤ºèŒƒï¼šåœ¨HSVç©ºé—´ç›´æ¥åšCanny
hsv_edges = cv2.Canny(hsv_img, 30, 150)  # è¾“å‡ºä¼šå˜æˆæŠ½è±¡æ´¾æ²¹ç”»
```

**ç¿»è½¦2ï¼šæ ¸å°ºå¯¸ä¸­é‚ª**
```python
# ç”¨äº†å¶æ•°å°ºå¯¸çš„é«˜æ–¯æ ¸
cv2.GaussianBlur(img, (4,4), 0)  # æŠ¥é”™ä¿¡æ¯æ¯”ä½ çš„è¡€å‹è¿˜é«˜
```

**ç¿»è½¦3ï¼šé˜ˆå€¼è¿‡ç•Œæƒ¨æ¡ˆ**
```python
# CLAHEçš„clipLimitè®¾æˆ100
clahe = cv2.createCLAHE(clipLimit=100, ...)  # å›¾åƒç›´æ¥èµ›åšæœ‹å…‹åŒ–
```

---

### ğŸ§ª **å®éªŒå®¤ç§˜ç±**

**ç§˜ç±1ï¼šè‡ªé€‚åº”äºŒå€¼åŒ–ï¼ˆæ™ºèƒ½ç¾é¢œï¼‰**
```python
binary = cv2.adaptiveThreshold(
    gray_img, 
    255, 
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY, 
    11,  # è¿™ä¸ªå€¼å¿…é¡»æ˜¯å¥‡æ•°ï¼Œå¦åˆ™...
    2    # å¾®è°ƒå‚æ•°å°±åƒè°ƒç«é”…è˜¸æ–™
)
```

**ç§˜ç±2ï¼šé€è§†å˜æ¢ï¼ˆè¯ä»¶ç…§ä¿®æ­£æœ¯ï¼‰**
```python
# é€‰å–å›¾åƒçš„å››ä¸ªç‚¹åæ ‡
src_points = np.float32([[x1,y1], [x2,y2], [x3,y3], [x4,y4]])
dst_points = np.float32([[0,0], [w,0], [w,h], [0,h]])

M = cv2.getPerspectiveTransform(src_points, dst_points)
warped = cv2.warpPerspective(img, M, (w,h))
```

**ç§˜ç±3ï¼šå›¾åƒé‡‘å­—å¡”ï¼ˆç¼©æ”¾ã®è‰ºæœ¯ï¼‰**
```python
# é«˜æ–¯é‡‘å­—å¡”ï¼šå‘ä¸‹é‡‡æ ·
smaller = cv2.pyrDown(img)
# æ‹‰æ™®æ‹‰æ–¯é‡‘å­—å¡”ï¼šä¿ç•™é«˜é¢‘ä¿¡æ¯
laplacian = cv2.Laplacian(img, cv2.CV_64F)
```

---

### âš¡ **æ€§èƒ½ç„å­¦å¯¹æ¯”**

| æ“ä½œ                | æš´åŠ›å®ç°              | OpenCVä¼˜åŒ–ç‰ˆ         | æ•ˆæœå·®å¼‚                |
|---------------------|---------------------|---------------------|-------------------------|
| å›¾åƒæ—‹è½¬            | è‡ªå·±å†™åŒçº¿æ€§æ’å€¼      | cv2.warpAffine      | é€Ÿåº¦å·®10å€ï¼Œè¾¹ç¼˜æ›´å¹³æ»‘   |
| é¢œè‰²è¿‡æ»¤            | éå†æ¯ä¸ªåƒç´ åˆ¤æ–­      | cv2.inRange         | å¿«50å€ï¼Œè¿˜æ”¯æŒæ©è†œæ“ä½œ  |
| æ¨¡æ¿åŒ¹é…            | çº¯Pythonæ»‘åŠ¨çª—å£     | cv2.matchTemplate   | å¿«100å€ï¼Œè‡ªå¸¦6ç§åŒ¹é…ç®—æ³• |

---

### ğŸ¤– **è®¡ç®—æœºè§†è§‰å·¥ç¨‹å¸ˆã®æ€ªç™–**
1. çœ‹åˆ°ç°å®ä¸–ç•Œçš„ç‰©ä½“ä¼šè‡ªåŠ¨è„‘è¡¥HSVé€šé“
2. æ€»è§‰å¾—é«˜æ–¯æ¨¡ç³Šæ˜¯è§£å†³ä¸€åˆ‡é—®é¢˜çš„é“¶å¼¹
3. å¯¹thresholdçš„å–å€¼æœ‰è¿‘ä¹å®—æ•™èˆ¬çš„æ‰§å¿µ
4. é‡åˆ°æŠ¥é”™å…ˆæ£€æŸ¥æ˜¯ä¸æ˜¯å¿˜äº†è½¬ç°åº¦å›¾
5. åšä¿¡æ‰€æœ‰å›¾åƒé—®é¢˜éƒ½èƒ½ç”¨"é¢„å¤„ç†+CNN"è§£å†³

---

**è¯¾åä½œä¸š**ï¼š
1. æŠŠå®¤å‹çš„ç…§ç‰‡å¤„ç†æˆã€Šé»‘å®¢å¸å›½ã€‹é£æ ¼ï¼ˆç»¿+é»‘+ä»£ç é›¨ï¼‰
2. åœ¨å¨æˆ¿ç›‘æ§è§†é¢‘é‡Œå®æ—¶æ£€æµ‹é£è¿‡çš„èŸ‘è‚
3. ç»™æ ¡å›­å¡ç…§ç‰‡è‡ªåŠ¨æ·»åŠ "ä»…é™æ ¡å†…ä½¿ç”¨"é˜²ä¼ªæ°´å°

ï¼ˆé™„åŠ é¢˜ï¼šå½“äº§å“ç»ç†è¯´"è¿™ä¸ªæ¨¡ç³Šæ•ˆæœä¸å¤Ÿè‰ºæœ¯"æ—¶ï¼Œè¯·ä¼˜é›…åœ°æ‰“å¼€cv2.ximgproc.createSuperpixelSLICæ–‡æ¡£ï¼‰

## Part III: PyTorchæ¨¡å‹è½¬LibTorch(C++)çš„éƒ¨ç½²




**ã€ŠPyTorchæ¨¡å‹ç§»æ°‘è®¡åˆ’ï¼šä»Pythonå¤§åˆ«å¢…æ¬è¿›C++å°å…¬å¯“ã€‹**

---

### ğŸ§³ **å‰æƒ…æè¦ï¼šæ¨¡å‹æ‰“åŒ…è¡Œæ**
å‡è®¾ä½ è®­ç»ƒäº†ä¸€ä¸ªå®Œç¾æ¨¡å‹ï¼Œä½†ç”²æ–¹è¯´ï¼š"è¦éƒ¨ç½²åˆ°æ²¡æœ‰Pythonç¯å¢ƒçš„å·¥æ§æœºï¼"
```python
# Pythonè±ªå®…é‡Œçš„æƒ¬æ„ç”Ÿæ´»
model = torch.load("è‡³å°Šç‹è€…æ¨¡å‹.pth")
output = model(input_tensor)
```

---

### ğŸ›« **ç§»æ°‘ç¬¬ä¸€æ­¥ï¼šæ‹¿åˆ°TorchScriptç»¿å¡**
ç”¨TorchScriptæŠŠæ¨¡å‹å˜æˆè·¨è¯­è¨€å…¬æ°‘

**åœºæ™¯Aï¼šä¹–å·§æ¨¡å‹ï¼ˆæ— åˆ†æ”¯/å¾ªç¯ï¼‰**
```python
# ç›´æ¥traceè®°å½•æ¨¡å‹æ‰§è¡Œè·¯å¾„
example_input = torch.rand(1,3,224,224)
traced_model = torch.jit.trace(model, example_input)
traced_model.save("ç§»æ°‘ç‰ˆæ¨¡å‹.pt")  # æ‹¿åˆ°é€šè¡Œè¯ï¼
```

**åœºæ™¯Bï¼šç‹¡è¯ˆæ¨¡å‹ï¼ˆå¸¦if/forï¼‰**
```python
# éœ€è¦scriptæ³¨è§£å¤„ç†åŠ¨æ€é€»è¾‘
@torch.jit.script
def complex_logic(x: torch.Tensor) -> torch.Tensor:
    if x.mean() > 0.5:
        return x * 2
    else:
        return x - 1

scripted_model = torch.jit.script(model)
scripted_model.save("å¿ƒæœºæ¨¡å‹.pt")
```

**âš ï¸ æµ·å…³æ£€æŸ¥**ï¼šç”¨`torch.jit.optimize_for_inference`åšæœ€åå®‰æ£€

---

### ğŸ¡ **C++æ–°å®¶è£…ä¿®æŒ‡å—**
LibTorchç¯å¢ƒé…ç½®å°±åƒç»„è£…å®œå®¶å®¶å…·

**æ­¥éª¤1ï¼šä¸‹è½½LibTorchå·¥å…·ç®±**
- [å®˜ç½‘](https://pytorch.org/)é€‰æ‹©å¯¹åº”ç‰ˆæœ¬ï¼ˆCPUç‰ˆæ¯”GPUç‰ˆå°10å€ï¼ï¼‰
- è§£å‹åç›®å½•ç»“æ„ï¼š
  ```
  libtorch/
    â”œâ”€â”€ bin/     # åŠ¨æ€é“¾æ¥åº“(.dll/.so)
    â”œâ”€â”€ include/ # å¤´æ–‡ä»¶
    â””â”€â”€ lib/     # é™æ€åº“(.lib/.a)
  ```

**æ­¥éª¤2ï¼šCMakeè£…ä¿®æ‰‹å†Œ**
```cmake
cmake_minimum_required(VERSION 3.0)
project(æ¨¡å‹å°å±‹)

# å‘Šè¯‰ç¼–è¯‘å™¨å»å“ªæ‰¾å®¶å…·
set(CMAKE_PREFIX_PATH "ä½ çš„/libtorchè·¯å¾„")
find_package(Torch REQUIRED)

add_executable(æ¨¡å‹å°å±‹ main.cpp)
target_link_libraries(æ¨¡å‹å°å±‹ "${TORCH_LIBRARIES}")
```

---

### ğŸš€ **C++æ–°ç”Ÿæ´»ï¼šæ¨¡å‹æ¨ç†æµæ°´çº¿**
è®©æ¨¡å‹åœ¨C++ç¯å¢ƒé‡Œæ‰“å·¥

**ä»£ç ç¤ºä¾‹ï¼šæ ‡å‡†æ¬ç –æµç¨‹**
```cpp
#include <torch/script.h>

int main() {
    // ç¬¬ä¸€æ­¥ï¼šå¸ƒç½®æ–°å®¶
    torch::Device device(torch::kCPU);  // GPUç”¨æˆ·æ¢æˆkCUDA
  
    // ç¬¬äºŒæ­¥ï¼šè¯·æ¨¡å‹è¿›é—¨
    torch::jit::script::Module model;
    try {
        model = torch::jit::load("ç§»æ°‘ç‰ˆæ¨¡å‹.pt");
        model.to(device);
    } catch (const c10::Error& e) {
        std::cerr << "æ¨¡å‹æ°´åœŸä¸æœ: " << e.what();
        return -1;
    }

    // ç¬¬ä¸‰æ­¥ï¼šå‡†å¤‡è¾“å…¥æ•°æ®ï¼ˆæ¯”Pythonä¸¥æ ¼ï¼ï¼‰
    std::vector<float> data = {0.1, 0.2, 0.3};  // å‡è£…è¿™æ˜¯é¢„å¤„ç†åçš„æ•°æ®
    auto input = torch::from_blob(data.data(), {1, 3}).to(device);
  
    // ç¬¬å››æ­¥ï¼šæ­£å¼å¼€å·¥
    std::vector<torch::jit::IValue> inputs;
    inputs.push_back(input);
    auto output = model.forward(inputs).toTensor();
  
    // ç¬¬äº”æ­¥ï¼šå¤„ç†è¾“å‡ºï¼ˆè½¬å›æ™®é€šæ•°æ®ï¼‰
    float* result = output.data_ptr<float>();
    std::cout << "é¢„æµ‹ç»“æœ: " << result[0] << std::endl;
  
    return 0;
}
```

---

### ğŸ”§ **å¸¸è§æ°´åœŸä¸æœç—‡çŠ¶**

**ç—‡çŠ¶1ï¼šæ¨¡å‹ç‰ˆæœ¬å†²çª**
- é”™è¯¯ä¿¡æ¯ï¼š`Unsupported operator version 11`
- **è¯æ–¹**ï¼šç”¨åŒç‰ˆæœ¬PyTorchå¯¼å‡ºå’Œç¼–è¯‘ï¼Œå¯¹é½ç‰ˆæœ¬å·

**ç—‡çŠ¶2ï¼šç¼ºå¤±æ“ä½œç¬¦**
- é”™è¯¯ä¿¡æ¯ï¼š`No such operator my_custom_op`
- **è¯æ–¹**ï¼š
  ```cpp
  // åœ¨C++ç«¯æ³¨å†Œè‡ªå®šä¹‰op
  static auto registry = torch::RegisterOperators()
      .op("my_namespace::my_custom_op", &my_custom_op_impl);
  ```

**ç—‡çŠ¶3ï¼šå†…å­˜æ³„æ¼**
- **è¯Šæ–­**ï¼šè¿è¡Œåå†…å­˜æŒç»­å¢é•¿
- **è¯æ–¹**ï¼šä½¿ç”¨`torch::NoGradGuard`å…³é—­æ¢¯åº¦è®¡ç®—
  ```cpp
  {
      torch::NoGradGuard no_grad;
      auto output = model.forward(inputs);
  }
  ```

---

### âš¡ **æ€§èƒ½è°ƒä¼˜ä¸‰æŠŠæ–§**

**æ–§å¤´1ï¼šå¼€å¯æ¨ç†æ¨¡å¼**
```cpp
torch::jit::GraphOptimizerEnabledGuard guard(false); // å…³é—­ä¼˜åŒ–å™¨
model.eval();  // åˆ‡æ¢è¯„ä¼°æ¨¡å¼
```

**æ–§å¤´2ï¼šå†…å­˜æ± è°ƒä¼˜**
```cpp
// è®¾ç½®çº¿ç¨‹æ± å’Œå†…å­˜åˆ†é…ç­–ç•¥
at::init_num_threads();
c10::set_optimizer_sgd_allocate_memory(true);
```

**æ–§å¤´3ï¼šé‡åŒ–å‹ç¼©**
```python
# åœ¨Pythonç«¯å…ˆåšé‡åŒ–
quantized_model = torch.quantization.quantize_dynamic(
    model, {torch.nn.Linear}, dtype=torch.qint8
)
```

---

### ğŸŒ **è·¨å¹³å°ç”Ÿå­˜æŒ‡å—**

**å®‰å“ç”Ÿå­˜åŒ…**ï¼š
- ä½¿ç”¨`ANDROID_ABI`æŒ‡å®šæ¶æ„
- æ·»åŠ `android_ndk`åˆ°CMakeè·¯å¾„

**åµŒå…¥å¼è®¾å¤‡ç˜¦èº«æœ¯**ï¼š
1. ç§»é™¤ä¸éœ€è¦çš„åº“æ–‡ä»¶ï¼ˆå¦‚ONNXç›¸å…³ï¼‰
2. ä½¿ç”¨`strip`å‘½ä»¤ç²¾ç®€äºŒè¿›åˆ¶
3. é™æ€é“¾æ¥ç¼–è¯‘ï¼ˆä½“ç§¯å¢å¤§ä½†ä¾èµ–å‡å°‘ï¼‰

---

### ğŸ•µï¸ **è°ƒè¯•æŠ€å·§ï¼šæ¨¡å‹ä¾¦æ¢å¥—è£…**

**ä¾¦æ¢1ï¼šæ‰“å°è®¡ç®—å›¾**
```cpp
model.dump(true, true, true);  // ä¸‰è¿trueçœ‹è¯¦ç»†ç»“æ„
```

**ä¾¦æ¢2ï¼šä¸­é—´å±‚çªƒå¬**
```cpp
// æ³¨å†Œå‰å‘ä¼ æ’­é’©å­
model.register_forward_pre_hook([](const Module& module, const IValue& input) {
    std::cout << "æ”¶åˆ°è¾“å…¥: " << input << std::endl;
});
```

**ä¾¦æ¢3ï¼šTensorå†…å®¹æ£€æŸ¥**
```cpp
std::cout << output.slice(/*dim=*/0, /*start=*/0, /*end=*/5) << std::endl; 
```

---

### ğŸ“Š **éƒ¨ç½²æ€§èƒ½æ“‚å°èµ›**

| æ“ä½œ                | Pythonæ¨ç†è€—æ—¶ | C++æ¨ç†è€—æ—¶ | ä¼˜åŠ¿åœºæ™¯               |
|---------------------|---------------|------------|-----------------------|
| ResNet50å›¾åƒåˆ†ç±»     | 120ms         | 45ms       | å®æ—¶è§†é¢‘åˆ†æ           |
| LSTMæ–‡æœ¬ç”Ÿæˆ         | 200ms         | 70ms       | é«˜å¹¶å‘èŠå¤©æœºå™¨äºº       |
| YOLOv5ç›®æ ‡æ£€æµ‹       | 150ms         | 55ms       | è¾¹ç¼˜è®¾å¤‡éƒ¨ç½²           |

---

### ğŸ¤– **C++å·¥ç¨‹å¸ˆã®è¯¡å¼‚ä¹ æƒ¯**
1. çœ‹åˆ°`torch::Tensor`ä¼šæ¯”çœ‹åˆ°äº²å„¿å­è¿˜äº²
2. å¯¹å†…å­˜åœ°å€çš„æ‰§å¿µè¶…è¿‡å¯¹å¥³æœ‹å‹çš„è®°å¿†
3. è§‰å¾—CMakeè¯­æ³•æ¯”èå£«æ¯”äºšåå››è¡Œè¯—æ›´ç¾
4. é‡åˆ°æ®µé”™è¯¯ä¼šéœ²å‡ºè¿·ä¹‹å¾®ç¬‘
5. åšä¿¡æ‰€æœ‰Pythonä»£ç éƒ½åº”è¯¥ç”¨C++é‡å†™

---

**è¯¾åä½œä¸š**ï¼š
1. æŠŠHello Worldæ¨¡å‹éƒ¨ç½²åˆ°æ ‘è“æ´¾ä¸Šå¹¶è¾¾åˆ°30FPS
2. å®ç°ä¸€ä¸ªC++ç‰ˆçš„MNISTå®æ—¶æ‰‹å†™è¯†åˆ«ç³»ç»Ÿ
3. åœ¨å®‰å“APPé‡Œé›†æˆLibTorchå®ç°æ»¤é•œæ•ˆæœ

ï¼ˆé™„åŠ é¢˜ï¼šå½“å®¢æˆ·è¯´"è¿™ä¸ªå»¶è¿Ÿè¿˜æ˜¯å¤ªé«˜äº†"ï¼Œè¯·ä¼˜é›…åœ°æ‰“å¼€`torch::jit::fuser::cuda`æ–‡æ¡£ï¼‰